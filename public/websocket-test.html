<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Socket.IO Modern Test Suite</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    :root {
      --primary: #4361ee;
      --primary-hover: #3a56d4;
      --success: #4cc9f0;
      --warning: #f8961e;
      --danger: #f94144;
      --light: #f8f9fa;
      --dark: #212529;
      --gray: #6c757d;
      --border-radius: 8px;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #f6f8ff 0%, #eef1f8 100%);
      color: var(--dark);
      line-height: 1.6;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #fff;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(90deg, #4361ee 0%, #4cc9f0 100%);
      color: white;
      padding: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--gray);
      transition: var(--transition);
    }

    .status-text {
      font-size: 0.85rem;
      font-weight: 500;
    }

    .connected .status-indicator {
      background: var(--success);
      box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.3);
    }

    .connecting .status-indicator {
      background: var(--warning);
      box-shadow: 0 0 0 2px rgba(248, 150, 30, 0.3);
    }

    .disconnected .status-indicator {
      background: var(--danger);
      box-shadow: 0 0 0 2px rgba(249, 65, 68, 0.3);
    }

    .connected .status-text {
      color: var(--success);
    }

    .connecting .status-text {
      color: var(--warning);
    }

    .disconnected .status-text {
      color: var(--danger);
    }

    .content {
      padding: 24px;
    }

    .panel {
      background: var(--light);
      border-radius: var(--border-radius);
      padding: 16px;
      margin-bottom: 16px;
    }

    .panel-header {
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-title {
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--gray);
    }

    .panel-icon {
      color: var(--primary);
    }

    .row {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .input-group {
      display: flex;
      flex: 1;
      min-width: 200px;
      position: relative;
    }

    input {
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      width: 100%;
      transition: var(--transition);
      font-size: 0.9rem;
    }

    input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }

    input::placeholder {
      color: #aaa;
    }

    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: var(--border-radius);
      background: var(--light);
      color: var(--dark);
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .btn:hover {
      background: #e9ecef;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: #41b9e2;
    }

    .btn-warning {
      background: var(--warning);
      color: white;
    }

    .btn-warning:hover {
      background: #e58519;
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background: #e53c3e;
    }

    .btn-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    .stat-card {
      background: white;
      border-radius: var(--border-radius);
      padding: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .stat-label {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--gray);
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 1rem;
      font-weight: 600;
    }

    #log {
      background: var(--dark);
      color: #f8f9fa;
      padding: 16px;
      border-radius: var(--border-radius);
      height: 300px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    #log div {
      margin-bottom: 4px;
      word-break: break-word;
    }

    #log .info {
      color: #f8f9fa;
    }

    #log .warn {
      color: #ffd166;
    }

    #log .error {
      color: #ef476f;
    }

    .user-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .user-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px solid #eee;
    }

    .user-item:last-child {
      border-bottom: none;
    }

    .user-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .user-name {
      font-size: 0.9rem;
    }

    .user-item.current .user-name {
      font-weight: 600;
      color: var(--primary);
    }

    .user-item.current .user-avatar {
      background: var(--primary);
    }

    .tab-container {
      margin-bottom: 16px;
    }

    .tabs {
      display: flex;
      gap: 2px;
      margin-bottom: 12px;
    }

    .tab {
      padding: 12px 20px;
      cursor: pointer;
      background: var(--light);
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      font-weight: 500;
      font-size: 0.9rem;
      color: var(--gray);
      transition: var(--transition);
    }

    .tab:hover {
      background: #e9ecef;
    }

    .tab.active {
      background: white;
      color: var(--primary);
      box-shadow: 0 -2px 0 var(--primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Chat Room Styles */
.chat-container {
  display: flex;
  height: 500px;
  background-color: var(--light);
  border-radius: var(--border-radius);
  overflow: hidden;
  box-shadow: var(--shadow);
}

.chat-sidebar {
  width: 250px;
  background-color: white;
  border-right: 1px solid #eee;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.chat-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: white;
}

.chat-messages {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
  background-color: #f8f9fa;
}

.chat-message {
  margin-bottom: 12px;
  padding: 8px 12px;
  border-radius: 8px;
  max-width: 80%;
  animation: fadeIn 0.3s;
}

.chat-message-self {
  background-color: #4361ee;
  color: white;
  align-self: flex-end;
  margin-left: auto;
}

.chat-message-other {
  background-color: white;
  border: 1px solid #eee;
  align-self: flex-start;
}

.chat-message-system {
  background-color: #f8f9fa;
  border: 1px solid #eee;
  color: #6c757d;
  font-style: italic;
  text-align: center;
  max-width: 100%;
  margin: 8px auto;
}

.chat-message-header {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
}

.chat-message-name {
  font-weight: 600;
  margin-right: 8px;
}

.chat-message-time {
  font-size: 0.8em;
  color: rgba(255, 255, 255, 0.7);
}

.chat-message-other .chat-message-time {
  color: #6c757d;
}

.chat-message-content {
  word-break: break-word;
}

.chat-input-container {
  display: flex;
  padding: 12px;
  border-top: 1px solid #eee;
}

.chat-input-container input {
  flex: 1;
  margin-right: 8px;
}

.welcome-message {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 20px;
  color: var(--gray);
  text-align: center;
  height: 100%;
}

.welcome-message i {
  font-size: 1.5rem;
  color: var(--primary);
}

.empty-chat-users {
  padding: 15px;
  text-align: center;
  color: var(--gray);
}

/* Responsive design for chat */
@media (max-width: 768px) {
  .chat-container {
    flex-direction: column;
    height: 600px;
  }
  
  .chat-sidebar {
    width: 100%;
    height: 150px;
    border-right: none;
    border-bottom: 1px solid #eee;
  }
}

/* Add right after the CSS styling section, before the closing </style> tag */
.user-offline {
  opacity: 0.5;
}

.user-offline .user-avatar {
  background-color: var(--gray);
}

.user-offline .user-name::after {
  content: " (Offline)";
  font-style: italic;
  font-size: 0.8em;
  color: var(--gray);
}

.user-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
  background-color: var(--success);
  display: inline-block;
  margin-right: 4px;
}

.user-offline .user-status {
  background-color: var(--gray);
}

.chat-message-disconnected {
  text-align: center;
  color: var(--gray);
  font-style: italic;
  margin: 10px 0;
}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1><i class="fas fa-plug"></i> Socket.IO Test Suite</h1>
      <div id="connectionStatus" class="connection-status">
        <div class="status-indicator"></div>
        <span class="status-text">NOT INITIALIZED</span>
      </div>
    </div>

    <div class="content">
      <div class="tab-container">
        <div class="tabs">
          <div class="tab active" data-tab="connection">Connection</div>
          <div class="tab" data-tab="testing">Testing</div>
          <div class="tab" data-tab="rooms">Rooms</div>
          <div class="tab" data-tab="stats">Statistics</div>
<div class="tab" data-tab="chat">Chat Room</div>
        </div>

        <!-- Connection Tab -->
        <div id="connection" class="tab-content active">
          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-network-wired panel-icon"></i>
              <h3 class="panel-title">Connection Controls</h3>
            </div>
            <div class="row">
              <div class="input-group">
                <input id="username" placeholder="Username for auth middleware" />
              </div>
              <button class="btn btn-primary" onclick="connectSocket()">
                <i class="fas fa-plug"></i> Connect
              </button>
              <button class="btn btn-danger" onclick="disconnectSocket()">
                <i class="fas fa-times-circle"></i> Disconnect
              </button>
            </div>
            <div class="row">
              <button class="btn btn-warning" onclick="forceReconnect()">
                <i class="fas fa-sync"></i> Force Reconnect
              </button>
            </div>
          </div>

          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-users panel-icon"></i>
              <h3 class="panel-title">Online Users</h3>
            </div>
            <ul id="onlineUsers" class="user-list">
              <!-- Users will be added here dynamically -->
            </ul>
          </div>
        </div>

        <!-- Testing Tab -->
        <div id="testing" class="tab-content">
          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-vial panel-icon"></i>
              <h3 class="panel-title">Test Events</h3>
            </div>
            <div class="row">
              <button class="btn btn-primary" onclick="emitTestEvent()">
                <i class="fas fa-paper-plane"></i> Test Event
              </button>
              <button class="btn btn-primary" onclick="emitAckTest()">
                <i class="fas fa-check-circle"></i> Ack Test
              </button>
              <button class="btn btn-primary" onclick="emitCustomPing()">
                <i class="fas fa-heartbeat"></i> Custom Ping
              </button>
            </div>
            <div class="row">
              <button class="btn btn-danger" onclick="emitErrorEvent()">
                <i class="fas fa-exclamation-triangle"></i> Emit Error
              </button>
            </div>
          </div>

          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-broadcast-tower panel-icon"></i>
              <h3 class="panel-title">Broadcast Message</h3>
            </div>
            <div class="row">
              <div class="input-group">
                <input id="broadcastMsg" placeholder="Broadcast message" />
              </div>
              <button class="btn btn-primary" onclick="sendBroadcast()">
                <i class="fas fa-bullhorn"></i> Broadcast
              </button>
            </div>
          </div>
        </div>

        <!-- Rooms Tab -->
        <div id="rooms" class="tab-content">
          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-door-open panel-icon"></i>
              <h3 class="panel-title">Room Management</h3>
            </div>
            <div class="row">
              <div class="input-group">
                <input id="roomName" placeholder="Room name" />
              </div>
              <button class="btn btn-success" onclick="joinRoom()">
                <i class="fas fa-sign-in-alt"></i> Join
              </button>
              <button class="btn btn-danger" onclick="leaveRoom()">
                <i class="fas fa-sign-out-alt"></i> Leave
              </button>
            </div>
          </div>

          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-comment-alt panel-icon"></i>
              <h3 class="panel-title">Room Message</h3>
            </div>
            <div class="row">
              <div class="input-group">
                <input id="roomMsg" placeholder="Message to room" />
              </div>
              <button class="btn btn-primary" onclick="sendRoomMessage()">
                <i class="fas fa-paper-plane"></i> Send
              </button>
            </div>
          </div>
        </div>

        <!-- Statistics Tab -->
        <div id="stats" class="tab-content">
          <div class="panel">
            <div class="panel-header">
              <i class="fas fa-chart-line panel-icon"></i>
              <h3 class="panel-title">Connection Statistics</h3>
            </div>
            <div class="stats">
              <div class="stat-card">
                <div class="stat-label">Connection Time</div>
                <div id="connTime" class="stat-value">-</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Uptime</div>
                <div id="uptime" class="stat-value">-</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Last Disconnect</div>
                <div id="lastDisconnect" class="stat-value">-</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Reconnect Count</div>
                <div id="reconnectCount" class="stat-value">0</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Status</div>
                <div id="wsStatus" class="stat-value">NOT INITIALIZED</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Chat Tab -->
        <div id="chat" class="tab-content">
  <div class="chat-container">
    <div class="chat-sidebar">
      <div class="panel-header">
        <i class="fas fa-users panel-icon"></i>
        <h3 class="panel-title">Online Users</h3>
      </div>
      <ul id="chat-user-list" class="user-list">
        <!-- Users will be added here dynamically -->
        <div class="empty-chat-users">No users online</div>
      </ul>
    </div>
    <div class="chat-main">
      <div class="panel-header">
        <i class="fas fa-comments panel-icon"></i>
        <h3 class="panel-title">Chat Messages</h3>
      </div>
      <div id="chat-messages" class="chat-messages">
        <div class="welcome-message">
          <i class="fas fa-info-circle"></i>
          <p>Welcome to the chat room! Connect to start chatting.</p>
        </div>
      </div>
      <div class="chat-input-container">
        <input id="chat-input" type="text" placeholder="Type a message..." disabled />
        <button id="chat-send-btn" class="btn btn-primary" disabled>
          <i class="fas fa-paper-plane"></i> Send
        </button>
      </div>
    </div>
  </div>
</div>
      </div>
<!-- Add this to your tab navigation in the existing HTML -->
<div class="tab" data-tab="loadtest">Load Testing</div>
<div class="tab" data-tab="latency">Latency Analysis</div>

<!-- Add these tab content sections -->
<div id="loadtest" class="tab-content">
  <div class="panel">
    <div class="panel-header">
      <i class="fas fa-tachometer-alt panel-icon"></i>
      <h3 class="panel-title">Load Test Configuration</h3>
    </div>
    <div class="row">
      <div class="input-group">
        <label for="clientCount">Virtual Clients:</label>
        <input id="clientCount" type="number" min="1" max="500" value="10" />
      </div>
      <div class="input-group">
        <label for="messageFrequency">Message Interval (ms):</label>
        <input id="messageFrequency" type="number" min="100" max="10000" value="1000" />
      </div>
    </div>
    <div class="row">
      <div class="input-group">
        <label for="testDuration">Test Duration (seconds):</label>
        <input id="testDuration" type="number" min="5" max="300" value="30" />
      </div>
      <button class="btn btn-primary" onclick="startLoadTest()">
        <i class="fas fa-play"></i> Start Load Test
      </button>
    </div>
  </div>
  
  <div class="panel">
    <div class="panel-header">
      <i class="fas fa-chart-bar panel-icon"></i>
      <h3 class="panel-title">Load Test Metrics</h3>
    </div>
    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">Messages Sent</div>
        <div id="messagesSent" class="stat-value">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Messages Received</div>
        <div id="messagesReceived" class="stat-value">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Message Rate</div>
        <div id="messageRate" class="stat-value">0/s</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Failure Rate</div>
        <div id="failureRate" class="stat-value">0%</div>
      </div>
    </div>
  </div>
</div>

<div id="latency" class="tab-content">
  <div class="panel">
    <div class="panel-header">
      <i class="fas fa-stopwatch panel-icon"></i>
      <h3 class="panel-title">Latency Metrics</h3>
    </div>
    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">Current Latency</div>
        <div id="currentLatency" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Average Latency</div>
        <div id="avgLatency" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Min Latency</div>
        <div id="minLatency" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Max Latency</div>
        <div id="maxLatency" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Connection Quality</div>
        <div id="connectionQuality" class="stat-value">-</div>
      </div>
    </div>
  </div>
  
  <div class="panel">
    <div class="panel-header">
      <i class="fas fa-chart-line panel-icon"></i>
      <h3 class="panel-title">Latency Graph</h3>
    </div>
    <div id="latencyChart" style="width:100%; height:200px; background:#f8f9fa; border-radius:var(--border-radius); display:flex; align-items:center; justify-content:center;">
      <span style="color:var(--gray);">Connect to see latency metrics</span>
    </div>
  </div>
</div>
      <!-- Log Panel (Always visible) -->
      <div class="panel">
        <div class="panel-header">
          <i class="fas fa-terminal panel-icon"></i>
          <h3 class="panel-title">Event Log</h3>
        </div>
        <div id="log"></div>
      </div>
    </div>
  </div>
<!-- Add to the log panel at the bottom of your page -->
<div class="panel-header">
  <i class="fas fa-terminal panel-icon"></i>
  <h3 class="panel-title">Event Log</h3>
  <div style="margin-left: auto; display: flex; gap: 8px;">
    <select id="logTypeFilter" class="filter-select">
      <option value="all">All Types</option>
      <option value="info">Info</option>
      <option value="warn">Warning</option>
      <option value="error">Error</option>
    </select>
    <select id="logCategoryFilter" class="filter-select">
      <option value="all">All Categories</option>
      <option value="connection">Connection</option>
      <option value="event">Events</option>
      <option value="room">Rooms</option>
      <option value="load">Load Test</option>
    </select>
    <input id="logSearch" placeholder="Search logs..." class="filter-input" />
    <button class="btn btn-icon" onclick="clearLogs()">
      <i class="fas fa-trash-alt"></i>
    </button>
    <button class="btn btn-icon" onclick="exportLogs()">
      <i class="fas fa-download"></i>
    </button>
  </div>
</div>
  <script src="/interac/socket.io/socket.io.js"></script>
  <script>
    let socket = null;
    let lastPingTime = null;
    let pingInterval = null;
    let connectTimestamp = null;
    let lastDisconnectTime = null;
    let reconnectCount = 0;
    let uptimeInterval = null;
    
    // Tab Management
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs and content
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding content
        tab.classList.add('active');
        const tabId = tab.getAttribute('data-tab');
        document.getElementById(tabId).classList.add('active');
      });
    });

    function log(msg, type = 'info') {
      const logDiv = document.getElementById('log');
      const el = document.createElement('div');
      el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      el.classList.add(type);
      logDiv.appendChild(el);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function updateDashboard() {
      document.getElementById('connTime').textContent = connectTimestamp ? new Date(connectTimestamp).toLocaleTimeString() : '-';
      document.getElementById('lastDisconnect').textContent = lastDisconnectTime ? new Date(lastDisconnectTime).toLocaleTimeString() : '-';
      document.getElementById('reconnectCount').textContent = reconnectCount;
      
      if (connectTimestamp) {
        const diff = Math.floor((Date.now() - connectTimestamp) / 1000);
        const min = Math.floor(diff / 60);
        const sec = diff % 60;
        document.getElementById('uptime').textContent = `${min}m ${sec}s`;
      } else {
        document.getElementById('uptime').textContent = '-';
      }
    }

    function startUptime() {
      if (uptimeInterval) clearInterval(uptimeInterval);
      uptimeInterval = setInterval(updateDashboard, 1000);
    }

    function stopUptime() {
      if (uptimeInterval) clearInterval(uptimeInterval);
      uptimeInterval = null;
    }

    function setStatusIndicator(status) {
      const statusEl = document.getElementById('connectionStatus');
      const statusText = statusEl.querySelector('.status-text');
      
      // Remove all status classes
      statusEl.classList.remove('connected', 'connecting', 'disconnected');
      
      if (status === 'CONNECTED') {
        statusEl.classList.add('connected');
        statusText.textContent = 'CONNECTED';
      } else if (status === 'CONNECTING') {
        statusEl.classList.add('connecting');
        statusText.textContent = 'CONNECTING';
      } else if (status === 'DISCONNECTED') {
        statusEl.classList.add('disconnected');
        statusText.textContent = 'DISCONNECTED';
      } else {
        statusText.textContent = 'NOT INITIALIZED';
      }
      
      // Also update the wsStatus element
      updateWebSocketStatus();
    }

    function updateWebSocketStatus() {
      const wsStatusEl = document.getElementById('wsStatus');
      
      if (socket && socket.connected) {
        wsStatusEl.textContent = 'CONNECTED';
        wsStatusEl.style.color = '#4cc9f0';
      } else if (socket && socket.disconnected) {
        wsStatusEl.textContent = 'DISCONNECTED';
        wsStatusEl.style.color = '#f94144';
      } else {
        wsStatusEl.textContent = 'NOT INITIALIZED';
        wsStatusEl.style.color = '#6c757d';
      }
    }

    function updateOnlineUsers(users) {
      const ul = document.getElementById('onlineUsers');
      ul.innerHTML = '';
      
      if (!Array.isArray(users) || users.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.textContent = 'No users online';
        emptyMessage.style.color = '#6c757d';
        emptyMessage.style.padding = '12px 0';
        emptyMessage.style.textAlign = 'center';
        ul.appendChild(emptyMessage);
        return;
      }
      
      users.forEach(user => {
        const li = document.createElement('li');
        li.className = 'user-item';
        
        // Handle both string usernames and user objects
        const username = typeof user === 'string' ? user : (user.username || 'Anonymous');
        const userId = typeof user === 'string' ? user : (user.userId || user.id || 'unknown');
        const status = typeof user === 'object' ? (user.status || 'online') : 'online';
        
        // Add current class if it's the current user
        if (username === window.currentUsername) {
          li.classList.add('current');
        }
        
        // Add status-specific classes
        if (status === 'offline' || status === 'disconnecting' || status === 'inactive') {
          li.classList.add('user-offline');
        }
        
        // Create avatar with first letter
        const avatar = document.createElement('div');
        avatar.className = 'user-avatar';
        avatar.textContent = (username && username.charAt(0).toUpperCase()) || '?';
        
        // Add status indicator
        const statusIndicator = document.createElement('span');
        statusIndicator.className = 'user-status';
        
        const name = document.createElement('div');
        name.className = 'user-name';
        name.textContent = username || 'Anonymous';
        
        if (username === window.currentUsername) {
          name.textContent += ' (You)';
        }
        
        // User status-specific text
        if (status === 'inactive') {
          li.title = 'User is inactive';
        } else if (status === 'disconnecting') {
          li.title = 'User is disconnecting';
        } else if (status === 'offline') {
          li.title = 'User is offline';
        }
        
        li.appendChild(statusIndicator);
        li.appendChild(avatar);
        li.appendChild(name);
        ul.appendChild(li);
      });
    }

    async function connectSocket() {
      setStatusIndicator('CONNECTING');
      if (socket && socket.connected) {
        log('Already connected.');
        return;
      }
      window.currentUsername = document.getElementById('username').value.trim() || 'Anonymous';
      const username = window.currentUsername;
      if (!username) {
        log('Please enter a username.', 'error');
        setStatusIndicator('DISCONNECTED');
        return;
      }
      let token = null;
      try {
        (async () => {
          try {
            const response = await fetch('/interac/api/auth/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ username })
            });
            const data = await response.json();
            if (response.ok && data.token) {
              token = data.token;
              localStorage.setItem('auth_token', token);
              log('Obtained JWT token for user: ' + username);
              completeConnection(token, username);
            } else {
              log('Login failed: ' + (data.error || 'Unknown error'), 'error');
              setStatusIndicator('DISCONNECTED');
            }
          } catch (err) {
            log('Login request failed: ' + err.message, 'error');
            setStatusIndicator('DISCONNECTED');
          }
        })();
      } catch (err) {
        log('Error in login process: ' + err.message, 'error');
        setStatusIndicator('DISCONNECTED');
      }
    }

function completeConnection(token, username) {
  if (!token) {
    log('No JWT token available. Cannot connect.', 'error');
    setStatusIndicator('DISCONNECTED');
    return;
  }
  
  // Disconnect any existing connection
  if (socket) {
    socket.disconnect();
  }
  
  socket = io({
    path: '/interac/socket.io',
    auth: { token, username }
  });
  
  // Connection events
  socket.on('connect', () => {
    log('Connected: ' + socket.id);
    connectTimestamp = Date.now();
    updateDashboard();
    startUptime();
    setStatusIndicator('CONNECTED');
    
    // Start the heartbeat mechanism to maintain presence
    startUserHeartbeat();
    
    socket.emit('user_join', window.currentUsername);

    // Enable chat UI when connected
    initChatUI();
    
    // Important: System message about connection
    addChatMessage({
      system: true,
      message: 'You have connected to the chat room.',
      timestamp: new Date().toISOString()
    });
  });
  
  socket.on('disconnect', reason => {
    log('Disconnected: ' + reason, 'warn');
    lastDisconnectTime = Date.now();
    updateDashboard();
    stopUptime();
    
    // Stop the heartbeat mechanism
    stopUserHeartbeat();
    
    setStatusIndicator('DISCONNECTED');
    
    // Disable chat UI
    const chatInput = document.getElementById('chat-input');
    const chatSendBtn = document.getElementById('chat-send-btn');
    if (chatInput) chatInput.disabled = true;
    if (chatSendBtn) chatSendBtn.disabled = true;
    if (chatInput) chatInput.placeholder = "Connect to start chatting...";
    
    // Add system message about disconnection
    addChatMessage({
      system: true,
      message: 'You have been disconnected from the chat.',
      timestamp: new Date().toISOString()
    });
  });
  
  // Set up the remaining event handlers
  setupSocketEventHandlers();
}

    function disconnectSocket() {
      if (socket) {
        socket.disconnect();
        log('Socket disconnected by user.');
        setStatusIndicator('DISCONNECTED');
      }
    }

    function emitTestEvent() {
      if (socket && socket.connected) {
        socket.emit('test_event', { time: new Date().toISOString() });
        log('Test event emitted.');
      } else {
        log('Socket not connected. Cannot emit test event.', 'error');
      }
    }

    function emitAckTest() {
      if (socket && socket.connected) {
        socket.emit('ack_test', { time: new Date().toISOString() }, response => {
          log('Ack test callback: ' + JSON.stringify(response));
        });
        log('Ack test emitted.');
      } else {
        log('Socket not connected. Cannot emit ack test.', 'error');
      }
    }

    function emitCustomPing() {
      if (socket && socket.connected) {
        lastPingTime = Date.now();
        socket.emit('custom_ping', { clientTime: new Date().toISOString() });
        log('Custom ping emitted.');
      } else {
        log('Socket not connected. Cannot emit custom ping.', 'error');
      }
    }

    function startPingInterval() {
      stopPingInterval();
      pingInterval = setInterval(() => {
        emitCustomPing();
      }, 5000);
    }

    function stopPingInterval() {
      if (pingInterval) clearInterval(pingInterval);
      pingInterval = null;
    }

    function forceReconnect() {
      if (socket) {
        socket.io.engine.close();
        log('Engine forcibly closed. Should trigger reconnect.');
      } else {
        log('Socket not initialized. Cannot force reconnect.', 'error');
      }
    }

    function emitErrorEvent() {
      if (socket && socket.connected) {
        socket.emit('error', 'Manual error event for test');
        log('Manual error event emitted.');
      } else {
        log('Socket not connected. Cannot emit error event.', 'error');
      }
    }

    function joinRoom() {
      const room = document.getElementById('roomName').value.trim();
      if (socket && socket.connected && room) {
        socket.emit('join_room', room);
        log('Join room emitted: ' + room);
      } else if (!room) {
        log('Please enter a room name.', 'warn');
      } else {
        log('Socket not connected. Cannot join room.', 'error');
      }
    }

    function leaveRoom() {
      const room = document.getElementById('roomName').value.trim();
      if (socket && socket.connected && room) {
        socket.emit('leave_room', room);
        log('Leave room emitted: ' + room);
      } else if (!room) {
        log('Please enter a room name.', 'warn');
      } else {
        log('Socket not connected. Cannot leave room.', 'error');
      }
    }

    function sendRoomMessage() {
      const room = document.getElementById('roomName').value.trim();
      const msg = document.getElementById('roomMsg').value.trim();
      if (socket && socket.connected && room && msg) {
        socket.emit('room_message', { room, message: msg });
        log(`Room message emitted to ${room}: ${msg}`);
        document.getElementById('roomMsg').value = '';
      } else if (!room) {
        log('Please enter a room name.', 'warn');
      } else if (!msg) {
        log('Please enter a message.', 'warn');
      } else {
        log('Socket not connected. Cannot send room message.', 'error');
      }
    }

    function sendBroadcast() {
      const msg = document.getElementById('broadcastMsg').value.trim();
      if (socket && socket.connected && msg) {
        socket.emit('broadcast_message', { message: msg });
        log('Broadcast message emitted: ' + msg);
        document.getElementById('broadcastMsg').value = '';
      } else if (!msg) {
        log('Please enter a message.', 'warn');
      } else {
        log('Socket not connected. Cannot send broadcast message.', 'error');
      }
    }

// Add these chat-specific variables
let chatMessages = [];
const MAX_CHAT_HISTORY = 100;

// Initialize chat UI elements
function initChatUI() {
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  
  // Fix: Check socket connection status directly
  if (socket && socket.connected) {
    chatInput.disabled = false;
    chatSendBtn.disabled = false;
    chatInput.placeholder = "Type a message...";
  } else {
    chatInput.disabled = true;
    chatSendBtn.disabled = true;
    chatInput.placeholder = "Connect to start chatting...";
  }
  
  // Add event listeners for chat input
  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendChatMessage();
    }
  });
  
  chatSendBtn.addEventListener('click', sendChatMessage);
}

// Send a chat message
function sendChatMessage() {
  const chatInput = document.getElementById('chat-input');
  const message = chatInput.value.trim();
  
  if (message && socket && socket.connected) {
    socket.emit('chat_message', { 
      message,
      timestamp: new Date().toISOString()
    });
    
    // Add to local chat display immediately (optimistic UI)
    addChatMessage({
      from: window.currentUsername,
      message,
      timestamp: new Date().toISOString(),
      isSelf: true
    });
    
    // Clear input
    chatInput.value = '';
  }
}

// Add a message to the chat display
function addChatMessage(message) {
  const chatMessagesEl = document.getElementById('chat-messages');
  const welcomeMessage = chatMessagesEl.querySelector('.welcome-message');
  
  // Remove welcome message if present
  if (welcomeMessage) {
    welcomeMessage.remove();
  }
  
  // Create message element
  const messageEl = document.createElement('div');
  messageEl.className = 'chat-message';
  
  // Determine message type
  if (message.system) {
    messageEl.classList.add('chat-message-system');
    messageEl.textContent = message.message;
  } else {
    // User message
    messageEl.classList.add(message.isSelf ? 'chat-message-self' : 'chat-message-other');
    
    // Message header with name and time
    const messageHeader = document.createElement('div');
    messageHeader.className = 'chat-message-header';
    
    const messageName = document.createElement('div');
    messageName.className = 'chat-message-name';
    messageName.textContent = message.from || 'Anonymous';
    
    const messageTime = document.createElement('div');
    messageTime.className = 'chat-message-time';
    messageTime.textContent = formatTime(message.timestamp);
    
    messageHeader.appendChild(messageName);
    messageHeader.appendChild(messageTime);
    
    // Message content
    const messageContent = document.createElement('div');
    messageContent.className = 'chat-message-content';
    messageContent.textContent = message.message;
    
    messageEl.appendChild(messageHeader);
    messageEl.appendChild(messageContent);
  }
  
  // Add to DOM
  chatMessagesEl.appendChild(messageEl);
  
  // Scroll to bottom
  chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
  
  // Store in message history
  chatMessages.push(message);
  if (chatMessages.length > MAX_CHAT_HISTORY) {
    chatMessages.shift();
  }
}

// Format timestamp for chat messages
function formatTime(timestamp) {
  try {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } catch (e) {
    return '—';
  }
}

// Update the chat user list
function updateChatUserList(users) {
  const userList = document.getElementById('chat-user-list');
  if (!userList) return;
  
  userList.innerHTML = '';
  
  if (!Array.isArray(users) || users.length === 0) {
    const emptyEl = document.createElement('div');
    emptyEl.className = 'empty-chat-users';
    emptyEl.textContent = 'No users online';
    userList.appendChild(emptyEl);
    return;
  }
  
  users.forEach(user => {
    const username = typeof user === 'string' ? user : (user.username || 'Anonymous');
    
    const li = document.createElement('li');
    li.className = 'user-item';
    
    // Highlight current user
    if (username === window.currentUsername) {
      li.classList.add('current');
    }
    
    // Create avatar with first letter
    const avatar = document.createElement('div');
    avatar.className = 'user-avatar';
    avatar.textContent = (username.charAt(0) || '?').toUpperCase();
    
    const name = document.createElement('div');
    name.className = 'user-name';
    name.textContent = username;
    if (username === window.currentUsername) {
      name.textContent += ' (You)';
    }
    
    li.appendChild(avatar);
    li.appendChild(name);
    userList.appendChild(li);
  });
}

// ----- Modify the existing socket.on handlers to add chat support -----

// Fix: Connect all Socket.IO event handlers properly
function setupChatHandlers(socket) {
  // Chat message received
  socket.on('chat_message', (data) => {
    log(`Chat message from ${data.from}: ${data.message}`);
    
    // Add to chat display
    addChatMessage({
      from: data.from,
      message: data.message,
      timestamp: data.timestamp || new Date().toISOString(),
      isSelf: data.from === window.currentUsername
    });
  });
  
  // System message when connected
  addChatMessage({
    system: true,
    message: 'You have connected to the chat room.',
    timestamp: new Date().toISOString()
  });
  
  // Enable chat inputs
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  if (chatInput) chatInput.disabled = false;
  if (chatSendBtn) chatSendBtn.disabled = false;
  if (chatInput) chatInput.placeholder = "Type a message...";
}

// Modify the connectSocket function to add chat handlers
const originalConnectSocket = connectSocket;
connectSocket = async function() {
  await originalConnectSocket.apply(this, arguments);
  
  if (socket && socket.connected) {
    // Fix: Set up chat handlers immediately after connection
    setupChatHandlers(socket);
    // Update chat UI
    initChatUI();
  }
};

// Modify user_list handler to update both user lists
const originalUpdateOnlineUsers = updateOnlineUsers;
updateOnlineUsers = function(users) {
  originalUpdateOnlineUsers.apply(this, arguments);
  
  // Also update the chat user list
  updateChatUserList(users);
};

// Fix: Remove redundant connect/disconnect handlers that might conflict
// and instead attach them directly in the socket connection flow

// Initialize chat UI on page load
document.addEventListener('DOMContentLoaded', () => {
  initChatUI();
  
  // Also fix: If socket is already connected when viewing the chat tab, enable chat
  document.querySelectorAll('.tab').forEach(tab => {
    if (tab.dataset.tab === 'chat') {
      tab.addEventListener('click', () => {
        // When user clicks on chat tab, check if we're already connected
        if (socket && socket.connected) {
          const chatInput = document.getElementById('chat-input');
          const chatSendBtn = document.getElementById('chat-send-btn');
          if (chatInput) chatInput.disabled = false;
          if (chatSendBtn) chatSendBtn.disabled = false;
          if (chatInput) chatInput.placeholder = "Type a message...";
        }
      });
    }
  });
});
  </script>
<script>
  /**
   * Chat Adapter - Connects the robust chat system to the websocket-test.html implementation
   */
  document.addEventListener('DOMContentLoaded', () => {
    // Common typos and corrections for error handling
    const commonCorrections = {
      'recieve': 'receive',
      'alot': 'a lot',
      'seperate': 'separate',
      'definately': 'definitely',
      'accomodate': 'accommodate',
      'occured': 'occurred',
      'tommorrow': 'tomorrow',
      'wierd': 'weird',
      'didnt': "didn't",
      'dont': "don't",
      'cant': "can't",
      'wont': "won't",
      'isnt': "isn't",
      'shouldnt': "shouldn't",
      'wouldnt': "wouldn't",
      'couldnt': "couldn't",
      'im': "I'm",
      'theres': "there's",
      'theyre': "they're",
      'thats': "that's"
    };
    
    // Typing indicators
    let typingUsers = new Set();
    let typingTimeout = null;
    
    // Override the socket.on for chat_message to include error correction
    const originalHandlers = {};
    
    // Modify the existing send function to include typing indicators
    const originalSendChatMessage = window.sendChatMessage;
    window.sendChatMessage = function() {
      const chatInput = document.getElementById('chat-input');
      const message = chatInput.value.trim();
      
      if (message && socket && socket.connected) {
        // Apply spelling corrections
        const { correctedMessage, corrections } = correctSpelling(message);
        
        socket.emit('chat_message', {
          message: correctedMessage,
          timestamp: new Date().toISOString(),
          corrections // Add corrections metadata
        });
        
        // Cancel any typing indicators
        cancelTypingIndicator();
        
        // Add to local chat display immediately (optimistic UI)
        addChatMessage({
          from: window.currentUsername,
          message: correctedMessage,
          timestamp: new Date().toISOString(),
          isSelf: true,
          corrections
        });
        
        // Clear input
        chatInput.value = '';
        chatInput.focus();
      }
    };
    
    // Override the addChatMessage function to handle corrections
    const originalAddChatMessage = window.addChatMessage;
    window.addChatMessage = function(message) {
      const chatMessagesEl = document.getElementById('chat-messages');
      const welcomeMessage = chatMessagesEl.querySelector('.welcome-message');
      
      // Remove welcome message if present
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      // Create message element
      const messageEl = document.createElement('div');
      messageEl.className = 'chat-message';
      
      // Determine message type
      if (message.system) {
        messageEl.classList.add('chat-message-system');
        messageEl.textContent = message.message;
      } else {
        // User message
        messageEl.classList.add(message.isSelf ? 'chat-message-self' : 'chat-message-other');
        
        // Message header with name and time
        const messageHeader = document.createElement('div');
        messageHeader.className = 'chat-message-header';
        
        const messageName = document.createElement('div');
        messageName.className = 'chat-message-name';
        messageName.textContent = message.from || 'Anonymous';
        
        const messageTime = document.createElement('div');
        messageTime.className = 'chat-message-time';
        messageTime.textContent = formatTime(message.timestamp);
        
        messageHeader.appendChild(messageName);
        messageHeader.appendChild(messageTime);
        
        // Message content
        const messageContent = document.createElement('div');
        messageContent.className = 'chat-message-content';
        
        // If there are corrections, highlight them
        if (message.corrections && Object.keys(message.corrections).length > 0) {
          let content = message.message;
          
          // Add correction highlights
          for (const [original, corrected] of Object.entries(message.corrections)) {
            const regex = new RegExp(`\\b${corrected.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'g');
            content = content.replace(regex, `<span class="correction" 
                       title="Corrected from: '${original}'">${corrected}</span>`);
          }
          
          messageContent.innerHTML = content;
        } else {
          messageContent.textContent = message.message;
        }
        
        messageEl.appendChild(messageHeader);
        messageEl.appendChild(messageContent);
      }
      
      // Add to DOM
      chatMessagesEl.appendChild(messageEl);
      
      // Scroll to bottom
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      
      // Store in message history
      if (window.chatMessages) {
        window.chatMessages.push(message);
        if (window.chatMessages.length > window.MAX_CHAT_HISTORY) {
          window.chatMessages.shift();
        }
      }
    };
    
    // Add CSS for corrections
    const style = document.createElement('style');
    style.textContent = `
      .chat-message .correction {
        text-decoration: underline;
        text-decoration-style: wavy;
        text-decoration-color: #4cc9f0;
        position: relative;
      }
      
      .chat-message .correction:hover::after {
        content: attr(title);
        position: absolute;
        bottom: -20px;
        left: 0;
        background: #212529;
        color: white;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 4px;
        white-space: nowrap;
        z-index: 10;
      }
      
      .typing-indicator {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 8px 12px;
        background-color: rgba(67, 97, 238, 0.05);
        border-radius: 16px;
        margin-bottom: 8px;
        width: fit-content;
        font-size: 0.85rem;
        font-style: italic;
        color: #6c757d;
      }
      
      .typing-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background-color: #4361ee;
        opacity: 0.6;
        animation: typingDot 1s infinite;
      }
      
      .typing-dot:nth-child(1) { animation-delay: 0s; }
      .typing-dot:nth-child(2) { animation-delay: 0.2s; }
      .typing-dot:nth-child(3) { animation-delay: 0.4s; }
      
      @keyframes typingDot {
        0%, 60%, 100% { transform: translateY(0); }
        30% { transform: translateY(-4px); }
      }
    `;
    document.head.appendChild(style);
    
    // Add event listener for typing indicator
    const chatInput = document.getElementById('chat-input');
    if (chatInput) {
      chatInput.addEventListener('input', sendTypingStatus);
    }
    
    // Connect with socket.io handlers for typing
    function setupEnhancedChatHandlers() {
      if (!socket) return;
      
      // User typing handlers
      socket.on('user_typing', (data) => {
        if (data.username !== window.currentUsername) {
          showTypingIndicator(data.username);
        }
      });
      
      socket.on('user_stop_typing', (data) => {
        if (data.username !== window.currentUsername) {
          hideTypingIndicator(data.username);
        }
      });
    }
    
    // Helper functions
    function correctSpelling(message) {
      let correctedMessage = message;
      const corrections = {};
      
      // Split message into words
      const words = message.split(/\s+/);
      
      // Check each word against common corrections
      for (let i = 0; i < words.length; i++) {
        const word = words[i].toLowerCase().replace(/[.,?!;:'"()]/g, '');
        
        if (commonCorrections[word]) {
          // Save the original word and its correction
          corrections[words[i]] = commonCorrections[word];
          
          // Replace the word in the corrected message
          // Preserve original capitalization and punctuation
          const punctuation = words[i].match(/[.,?!;:'"()]/g) || [];
          const preserveCase = words[i][0] === words[i][0].toUpperCase();
          
          let correction = commonCorrections[word];
          if (preserveCase) {
            correction = correction.charAt(0).toUpperCase() + correction.slice(1);
          }
          
          correctedMessage = correctedMessage.replace(
            new RegExp(`\\b${words[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'g'), 
            correction + punctuation.join('')
          );
        }
      }
      
      return { correctedMessage, corrections };
    }
    
    function formatTime(timestamp) {
      try {
        const date = new Date(timestamp);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch (e) {
        return '—';
      }
    }
    
    function sendTypingStatus() {
      if (!socket || !socket.connected) return;
      
      // Clear previous timeout
      if (typingTimeout) {
        clearTimeout(typingTimeout);
      }
      
      // Emit typing event
      socket.emit('user_typing', { username: window.currentUsername });
      
      // Set timeout to emit stop typing after 2 seconds
      typingTimeout = setTimeout(() => {
        socket.emit('user_stop_typing', { username: window.currentUsername });
        typingTimeout = null;
      }, 2000);
    }
    
    function cancelTypingIndicator() {
      if (!socket || !socket.connected) return;
      
      if (typingTimeout) {
        clearTimeout(typingTimeout);
        typingTimeout = null;
      }
      
      socket.emit('user_stop_typing', { username: window.currentUsername });
    }
    
    function showTypingIndicator(username) {
      const chatMessagesEl = document.getElementById('chat-messages');
      if (!chatMessagesEl) return;
      
      // Add username to typing users set
      typingUsers.add(username);
      
      // Update typing indicator
      updateTypingIndicator();
    }
    
    function hideTypingIndicator(username) {
      // Remove username from typing users set
      typingUsers.delete(username);
      
      // Update typing indicator
      updateTypingIndicator();
    }
    
    function updateTypingIndicator() {
      const chatMessagesEl = document.getElementById('chat-messages');
      if (!chatMessagesEl) return;
      
      // Remove any existing typing indicators
      const existingIndicator = chatMessagesEl.querySelector('.typing-indicator');
      if (existingIndicator) {
        existingIndicator.remove();
      }
      
      // If nobody is typing, return
      if (typingUsers.size === 0) return;
      
      // Create typing indicator
      const typingEl = document.createElement('div');
      typingEl.className = 'typing-indicator';
      
      // Add text based on who is typing
      let typingText = '';
      if (typingUsers.size === 1) {
        typingText = `${Array.from(typingUsers)[0]} is typing`;
      } else if (typingUsers.size === 2) {
        typingText = `${Array.from(typingUsers).join(' and ')} are typing`;
      } else {
        typingText = 'Several people are typing';
      }
      typingEl.textContent = typingText + ' ';
      
      // Add animated dots
      for (let i = 0; i < 3; i++) {
        const dot = document.createElement('span');
        dot.className = 'typing-dot';
        typingEl.appendChild(dot);
      }
      
      // Add to DOM
      chatMessagesEl.appendChild(typingEl);
      
      // Scroll to bottom if near bottom
      if (chatMessagesEl.scrollHeight - chatMessagesEl.scrollTop < chatMessagesEl.clientHeight + 100) {
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }
    }
    
    // Set up enhanced chat handlers when socket is connected
    const originalSetupChatHandlers = window.setupChatHandlers || function() {};
    window.setupChatHandlers = function(socket) {
      originalSetupChatHandlers.apply(this, arguments);
      setupEnhancedChatHandlers();
    };
    
    // Initialize if socket is already connected
    if (socket && socket.connected) {
      setupEnhancedChatHandlers();
    }
    
    // Monitor for new socket connections
    const originalConnectSocket = window.connectSocket || function() {};
    window.connectSocket = async function() {
      await originalConnectSocket.apply(this, arguments);
      
      if (socket && socket.connected) {
        setupEnhancedChatHandlers();
      }
    };
    
    log('Chat enhancements loaded with error correction and typing indicators');
  });
</script>
<script>
  // Add user heartbeat function to periodically notify the server that the user is still active
function startUserHeartbeat() {
  // Clear any existing heartbeat interval
  if (window.heartbeatInterval) {
    clearInterval(window.heartbeatInterval);
  }
  
  // Create a new heartbeat interval that runs every 15 seconds
  window.heartbeatInterval = setInterval(() => {
    if (socket && socket.connected) {
      // Emit heartbeat to server
      socket.emit('user:heartbeat');
    } else {
      // If socket disconnected, stop heartbeat
      stopUserHeartbeat();
    }
  }, 15000); // Every 15 seconds
}

function stopUserHeartbeat() {
  if (window.heartbeatInterval) {
    clearInterval(window.heartbeatInterval);
    window.heartbeatInterval = null;
  }
}
  </script>
</body>
</html>